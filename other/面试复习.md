---
title: 面试复习
date: 2020-04-12 23:30:12
tags:
- 面试
- 基础
---
### 面试复习
<!--more -->

[toc]

#### 执行上下文

就是JavaScript代码在不同环境下运行的不同外部状态，作用域是它变量对象的体现。

有三种不同的外部运行环境：全局环境，函数环境，eval

执行上下文通过栈的抽象形式被JavaScript引擎访问。切洋葱

生命周期分为创建阶段和代码执行阶段

创建阶段会创建变量对象，建立作用域链，确定this的指向

执行阶段会完成变量赋值，函数引用等

##### 创建阶段

**1.创建变量对象**

- 检查函数参数，创建argument对象，在argument对象中以**“参数名：值/引用”**的方式存储，还有一个字段length指示参数长度

- 检查函数function声明，在变量对象中以**“函数名：函数内存地址”**的形式存储
- 检查变量var声明，优先级比函数低，在变量对象中以**“变量名：undefined”**形式存储

此时不能访问变量对象中的属性

**2.建立作用域链**

通过scope属性存储自身以及父级变量，访问形式由栈形式访问

**3.确定this指向**

##### 执行阶段

变量对象转为活动对象，里面的属性可以访问，代码执行顺序则按照上到下

#### 作用域

根据查询活动对象AV所形成的外在体现

#### 作用域链

在当前作用域访问某变量访问不了，则到父级作用域访问，直到该变量被访问到或到达全局环境仍然没有访问到，报 is not defined

#### 闭包

子函数访问父级作用域及以上的变量时则子函数形成闭包。

通过闭包可以在其他的执行上下文中访问到某个函数的内部变量。

#### this

执行上下文创建的时候确定指向，即在函数被调用的时刻确定指向。一个执行上下文只能有一个this，在执行上下文的生命周期this不会改变。

全局对象的this，就是指向它自己

函数的this：**如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined**。

##### 通过new操作符调用构造函数

1.创建新对象

2.将该中间对象的隐式原型`__proto__`指向构造函数的原型prototype；

3.将构造函数的this，指向该中间对象；

4.返回新对象

#### 变量提升

就是通过var声明变量时，在创建执行上下文阶段时该变量以**“变量名：undefined**”形式存在变量对象中

#### 函数传参

函数参数的传递是值传递：当传递基本数据类型时，执行上下文复制了值，而传递引用数据类型时，传递的是该引用数据所存的地址

#### 事件循环机制

JavaScript首先执行全局的宏任务，遇到微任务将其放入微任务队列，当前宏任务结束后执行微任务队列，在执行微任务时遇到宏任务则将其放入宏任务队列，微任务清空后js引擎线程被暂停，由渲染线程执行对页面重绘等，完毕后js引擎线程又执行宏任务...循环往复，直至没有任务。

#### promise 对象保存着一个异步操作的结果。

#### 同源与跨域

##### 同源策略

同源策略的含义：脚本只能读取和所属文档来源相同的窗口和文档的属性。

##### 解决跨域问题

- **`document.domain`**:解决无法读取非同源网页的 Cookie问题，限制在子域名不同的情况下使用
- **`window.postMessage()`**:解决`iframe`与页面的消息传递

- **`jsonp`**：在script标签中使用get方法向其他域发出请求，在本地址内使用一个回调函数来承接。
- **`CORS`**，跨域资源分享，解决同源策略所带来的痛点，是解决跨域`ajax`请求的方法。分两组情况：
  - 1.不携带cookie，只需要在服务器端设置**Access-Control-Allow-Origin**；
  - 2.携带cookie，不仅后端设置`ACAO`，前端`XMLHttpRequest`的实例对象也要设置`.withCredentials = true`;

#### js中==和===的区别

==在比较时会做一次隐式类型转换，将两个值转换为统一类型再比较一次，而===如果第一次类型比较的时候不是统一类型就不再比较值是否相等，直接false。

#### 观察者模式

MVC，MVVM模型的思想，通过被观察者的变化，来改变观察者的状态。

#### bind，箭头函数，call，apply

- 箭头函数没有this，即建立箭头函数上下文时不会指定this；
- bind用于绑定函数运行时的this指向，bind谁，函数运行时this就指向谁，传入可迭代对象
- call用于设置函数执行上下文，传入可迭代对象
- apply同样用于设置函数执行上下文，传入类数组对象

#### localStorage和sessionStorage

- ls是存储在浏览器中，生命周期很长，ss是存储浏览器中，当页面被关闭，则会被消除；
- 不同浏览器无法共享localStorage或sessionStorage中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）；
- 不同页面或标签页间无法共享sessionStorage的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。
- 存储前需要将请求返回的json数据转化为字符串

#### 浏览器事件

##### 事件绑定

浏览器事件绑定可以在HTML中写，在JavaScript中既可以通过`.on<event>`绑定，也可以通过`.addEventListener（event，handler，[options]）`绑定，`removeEventListener(event, handler, [options])`解绑，注意handler为实名函数，不然不能取消绑定。

##### 事件冒泡

当元素绑定的事件被触发时，元素的监听事件执行后，会往外层元素走，遇到不同元素上的同类型的监听事件仍然会触发，直到遇到html标签、或document对象、或window，或是被停止。这就是事件冒泡。用于停止冒泡的方法是 `event.stopPropagation()`。

##### 事件委托

为了解决数量过多的同类事件的绑定与维护问题，利用事件的参数中event.target属性来给某种同类元素批量绑定事件。

利用事件冒泡，只给一个事件处理函数，就能处理某一个类型的所有事件。好处是减少dom操作，降低了回流和重绘的次数与几率，降低内存的损耗，能够优化前端的性能。

算法：

1. 在容器（container）上放一个处理程序。
2. 在处理程序中 —— 检查源元素 `event.target`。
3. 如果事件发生在我们感兴趣的元素（即处理的元素）内，那么处理该事件。

#### 对象的继承

原型链继承

构造函数继承

复制继承

es6的class继承

#### 深拷贝与浅拷贝

##### 深拷贝

`const onj1 = JSON.parse(JSON.stringify(obj))`,`json.stringify`将对象转化为字符串，parse将字符串转化为对象。

for...in + 递归

##### 浅拷贝

`const objto = object.assign(objed)`

扩展运算符`const objto = [...obj]`

#### 浏览器加载过程

##### 浏览器多进程

主进程，`GPU`进程，每个tab页自己就是新进程

##### tab进程有多线程

`gui`渲染线程，`js`引擎线程，事件触发线程，定时器线程，异步`http`请求线程

##### 详略过程

主进程获得`cpu`资源，开始`dns`查询，解析到对应的`ip`地址，然后对相应服务器的`ip`地址发起建立`tcp`连接的请求，在第三次握手过程中将`http`请求报文发送给服务器，服务器接收到请求后将数据反馈给主机，浏览器获得返回的数据后通过接口发送给相应的tab进程，tab进程得到消息后开始解析渲染，先解析HTML得到`dom`树，同时也解析`css`，二者混合得到渲染树，然后开始测量位置，绘制图像信息，发送给主进程，主进程打印到屏幕上。当渲染线程接触后`js`引擎线程就开始解释`js`代码。

#### 提高渲染效率

减小关键资源的大小：减少无用代码，动态局部渲染

延迟JavaScript非阻塞资源加载：因为`js`引擎线程和渲染线程互斥，将阻塞的js代码放到后面能提高渲染效率，而使用defer和`async`可以进行并行、异步加载

尽早加载，按需加载`css`，使用内联样式

将请求资源封装为一次请求可以获得的最大值

#### `typeof`和`instanceof`

`typeof`用于判断变量是否属于基本数据类型，判断类型总错是底层设计的原因。字节码低三位中没有数组类型，估计就判给了对象。

`instanceof`常用与判断自定义对象是否是我们的某个原型的实例，它主要是按照原型链查找，找到同一个祖先返回true。

获得一个比较准确的判断可以用`Object.prototype.toString.call `方法

#### 强缓存与协商缓存

##### 强缓存

当用户再次申请某资源时，根据该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息，如果cache-control的时间没到即缓存未过期，或expires规定的时间没到，则命中强缓存，此时返回200状态码，但是实际并未发起网络请求，而是使用缓存信息渲染。**有cache-control不会检查expires：**

##### 协商缓存

当未命中强缓存时，浏览器会向改地址发起一次网络请求，通过比较header字段的文件最后修改时间和浏览器最后请求时间，判断文件是否修改了。若未修改，则返回304状态码，浏览器用缓存渲染。若修改了，则返回200,状态码，正常返回资源，刷新缓存。

### `css`

#### 水平，垂直居中

#### 伪元素的作用

清除浮动，如何清除？`clear：both`和`overflow：hidden`；优势是减少`dom`节点，劣势是不构成`dom`节点使得不能操作它，不利于`SEO`

#### media query 

 为了实现响应式布局而必须的，在meta标签声明name属性为`viewport `

#### box-sizing 盒模型

- 为border-box时盒子宽/高为**“内容+内边距+边框厚度”**
- 为content-box时，盒子宽/高仅为内容宽高，为盒子设置padding和border均会增加盒子大小
- inherit表示继承父级盒子的模型

#### 计算机网络

##### post和get

- post更安全
- post可以发送更多的数据类型
- post比get慢
- post用于提交和修改，而get用于获取资源

##### 安全

`xss`是攻击网站的信任用户（浏览器），`CSRF`是伪装成网站的受信任用户（通过cookie）来向服务器发起非法请求。

防御`xss`一个思想就是检查用户的输入,一个是使用`httponly`，防御`CSRF`则是在`http`请求头中添加`Referer`标识。



