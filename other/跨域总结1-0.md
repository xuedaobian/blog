---
title: 跨域总结1.0
date: 2020-08-11 15:04:47
tags:
- 跨域
- 总结
---

开发过程中遇到了跨域问题，为了提高“内卷”，故总结。

[TOC]

<!--more-->

# 一、同源策略

同源策略的制定是跨域问题的由来，因为有了同源策略才导致跨域难的问题。

所谓的同源策略指的是：浏览器为了浏览网页的用户的信息安全，以及提供网页服务的服务商的安全，制定的安全规则。它的安全区是**相同协议下的相同域名内的相同端口**，这三者缺一不可。

一开始很好的阻断了 `xss` 和 `csfr` 攻击，但是随着服务商的体量越来越大，于是为了更好的为用户提供服务，节省费用，缓解服务器压力（太多人访问同一个服务器），多个域名间通信的要求就起来了，于是跨域成了硬性要求。

# 二、开始跨域

## 利用HTML语言的特性跨域

HTML里的 `srcipt` 标签是老跨域标签了，从一开始就利用它的 `src` 属性跨域了，今天我们可以逮住它来跨域。这种方式也叫作 `jsonp` 跨域。

```javascript
this.$http.jsonp('http://www.domain2.com:8080/login', { 
    params: {}, //参数
    jsonp: 'handleCallback' //返回的回调函数
   }).then((res) => { 
    	console.log(res); 
	})
```

但是 `script` 虽然小错不断，但是它不犯大错，它只支持 `get` 请求。

## 从同源策略执行之外

思考浏览器的同源策略是如何实现的：它是通过判断请求地址与发起地址之间的不同，拦截不同源的响应。所以可以在**浏览器外完成跨域**，或者让**不同页面之间可以通信**两种想法。

### 不同页面之间通信

首先要理解浏览器是主进程，然后这个进程下，不同页面是不同的分进程（有些优化消耗小的页面化为统一进程不在考虑中）。所以本质上是进程间通信，还是有可能实现的。

`H5` 新特性的 `window.postMessage` 是可以让不同页面通信的，它是通过获取另一个窗口的引用调用目标窗口的 `postMessage`方法来分发一个消息。接收消息的窗口可以根据需要自由处理，随便处理。语法问题访问 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage#The_dispatched_event)

其实还想写写 `iframe`的，但是一来不熟`iframe`，二来不是很喜欢，觉得不流行，就咕咕咕算了。

### 浏览器外完成跨域

核心是用代理服务器，但是还没做到，这个真的下次一定。

## 浏览器的妥协

浏览器（厂商）是也要吃饭的嘛，要是弄得太死板大家不用他了怎么办，所以其做出了一个让步，和服务提供商联合推出 `cors` 跨域资源共享策略。

### 简单了解

所以很明显这个需要浏览器和服务器共同努力，而在浏览器端，这些工作浏览器怕别人干不好或者乱来，他还是自己做好了，封装好了，浏览器端开发无变化，有变化的是服务器端。

而浏览器端是如何封装的呢，大概思想就是判断发起的请求是不是跨域没，跨域了就自动给你加点请求头，或者他先模拟请求一下（怕“用户”耍诈），符合预期再发起真实请求。浏览器的工作就这样。

关键在于服务器端，服务器接收了一个跨域请求，如果他设置了跨域，那就返回可以一些信息告诉浏览器它支持这次跨域；而计算机网络告诉我们这样的通信方式是通过响应头告知的，比如会有

```json
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
```

这些都是顾名思义的词，不难理解，允许的源路径，允许携带身份信息（cookie），允许设置响应头。只有 `ACAO` 是必须的，其他的看情况。

> 注意的是，如果要携带cookie，请求中也要将该请求对象的属性 `withCredentials` 设为 `true`; 且`ACAO` 不能设置为 *

### 简单（普通会员）请求和非简单请求（大会员）

还有一件事，上面说到浏览器它可能对请求添加请求头，也可能发起一起“假请求”，那为什么？

这就是**简单请求**和**非简单请求**的区别了。（理解为豹子头玩家和尊贵的会员）。

#### 简单请求

简单请求就是 `GET`, `POST`, `HEAD`这三种请求方法。

对于简单请求，浏览器直接加点特征（在请求头部添加一个Origin字段），表达一下这种请求很简单的，服务器你就这样这样给他服务就好了。（因为豹子头没追求吗？）

#### 非简单请求

对于非简单请求的话，则可以从方法和自定义的请求头判断。如 `PUT`, `DELETE`方法，或 `Content-Type`字段的类型是`application/json`。

浏览器判断这个请求是非简单请求，它会先发起一个预检请求。方法是 ·`OPTIONS`,携带三个请求头：

 `Origin` ：源路径

**Access-Control-Request-Method**：真实请求使用的请求方法

**Access-Control-Request-Headers**：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段（不是很懂）

##### 预检请求的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

如果允许就会返回一个有`cors`头信息的响应，然后浏览器发出非简单请求。

如果不允许则返回不含`CORS`相关的头信息字段的正常响应。然后报错提醒说请求不能执行，源路径不被允许跨域。

还有一些方便的字段：

>**（1）Access-Control-Allow-Methods**
>
>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。
>
>**（2）Access-Control-Allow-Headers**
>
>如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。
>
>**（3）Access-Control-Allow-Credentials**
>
>该字段与简单请求时的含义相同。
>
>**（4）Access-Control-Max-Age**
>
>该字段可选，用来指定本次预检请求的有效期，单位为秒，在此期间，不用发出另一条预检请求。

这一小节详细参考了 [阮一峰老师的博客](http://www.ruanyifeng.com/blog/2016/04/cors.html)

其实思想很容易理解，把简单请求类比于普通会员，非简单请求类比于大会员，普通会员就是统一服务的，大会员的一些权限需要验证，从你的来路，你要干什么（权限等级），悄悄验证一下（浏览器老欺软怕硬了）。然后很自然的，不能每次人家大会员来了你都验证一下吧，人家不要面子吗？上司也会问你是不是没有脑子。所以就设了个有效期，一段时间检查一下，很合理吧。好了，`cors`就到这了。

